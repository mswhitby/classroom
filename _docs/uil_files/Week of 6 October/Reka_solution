import java.io.*;
import java.util.*;
import java.util.regex.*;

public class Reka {
    public static void main(String[] args) throws IOException {
        Scanner scan = new Scanner(new File("reka.dat"));
        int T = scan.nextInt();
        assert 1 <= T && T <= 50;

        for (int caseNum = 1; caseNum <= T; caseNum++) {
            System.out.printf("Case #%d: %s\n", caseNum, solve(scan));
        }
    }

    private static String solve(Scanner scan) {
        long L = scan.nextLong(); // Length of the palindrome
        int c = scan.nextInt();  // Number of fixed characters

        assert 1 <= L && L <= 1e18;
        assert 0 <= c && c <= 200;
        assert c <= L;

        // 1. Initial count of unconstrained "pairs" (including the middle element if L is odd)
        long pairs = (L + 1) / 2;

        Map<Long, Character> map = new HashMap<>();
        for (int i = 0; i < c; i++) {
            long idx = scan.nextLong(); // 1-based index
            String s = scan.next();
            assert Pattern.matches("^[a-z]$", s);

            map.put(idx, s.charAt(0));
            // A fixed position is one less unconstrained pair/element
            pairs--;
        }

        // 2. Check for contradictions and correct "pairs" count for completed pairs
        for (Map.Entry<Long, Character> entry : map.entrySet()) {
            long other = L + 1 - entry.getKey(); // The mirrored index for a palindrome
            
            if (other == entry.getKey()) {
                // This is the middle element of an odd-length palindrome. 
                // It was correctly handled in the initial `pairs--` loop.
            } else if (entry.getKey() < other && map.containsKey(other)) {
                // We have a fully specified, matching pair of indices (idx and L+1-idx).
                
                // Contradiction Check: If the required characters are different, no palindrome is possible.
                if (entry.getValue() != map.get(other)) {
                    return "0";
                }

                // If the pair matches, we overcounted the reduction in step 1: 
                // both `idx` and `other` caused a `pairs--`. We only need to reduce by 1 for the pair.
                // Since the key is the smaller index, we restore the count.
                pairs++;
            }
        }

        // 3. Calculate 26^pairs (where 'pairs' is now the number of free positions/pairs)
        long exp = pairs;

        final long MOD = 1_000_000_000; // 10^9

        // Modular Exponentiation (Exponentiation by Squaring)
        long ans = 1;
        long base = 26L;
        while (exp > 0) {
            if (exp % 2 == 1) {
                ans = ans * base % MOD;
            }

            base = base * base % MOD;
            exp /= 2;
        }

        // 4. Output Formatting (with leading zeros for the modulus)
        if (pairs >= 7) { 
            // If pairs >= 7, the result (26^pairs) is guaranteed to be >= 10^9, 
            // so we need to ensure the full 9 digits of the MOD result are printed.
            return String.format("%09d", ans);
        } else {
            // Otherwise, print the number directly.
            return Long.toString(ans);
        }
    }
}
